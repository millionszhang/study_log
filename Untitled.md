##### 1、Spring AOP 底层原理

aop 底层是采用动态代理机制实现的：接口+实现类 
 如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代 理对象。 
 没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会 使用 Cglib 生成一个被代理对象的子类来作为代理。 
就是由代理创建出一个和 impl 实现类平级的一个对象，但是这个对象不是一个真正的对象， 只是一个代理对象，但它可以实现和 impl 相同的功能，这个就是 aop 的横向机制原理，这 样就不需要修改源代码

#### 2、HashMap 的底层数据结构是怎样的

当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会 执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容

#### 3、HashMap 的扩容机制是怎样的

 空参数的构造函数：实例化的 HashMap 默认内部数组是 null，即没有实例化。第一次 调用 put 方法时，则会开始第一次初始化扩容，长度为 16。 
 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的 2 的幂数， 将这个数设置赋值给阈值（threshold）。第一次调用 put 方法时，会将阈值赋值给容量， 然后让 阈值 = 容量 x 负载因子。
  如果不是第一次扩容，则容量变为原来的 2 倍，阈值也变为原来的 2 倍。（容量和阈值 都变为原来的 2 倍时，负载因子还是不变）。 
此外还有几个细节需要注意： 
 首次 put 时，先会触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容； 
 不是首次 put，则不再初始化，直接存入数据，然后判断是否需要扩容

#### 9、请你谈谈 MySQL 事务隔离级别，MySQL 的默认隔离级别是什么？ 

为了达到事务的四大特性，数据库定义了 4 种不同的事务隔离级别：  READ-UNCOMMITTED（读取未提交）：最低的隔离级别，允许脏读，也就是可能读取 到其他会话中未提交事务修改的数据，可能会导致脏读、幻读或不可重复读。 
 READ-COMMITTED（读取已提交）： 只能读取到已经提交的数据。Oracle 等多数数 据库默认都是该级别 （不重复读），可以阻止脏读，但是幻读或不可重复读仍有可能发 生。 
 REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据 是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。  SERIALIZABLE（可串行化）：最高的隔离级别，完全服从 ACID 的隔离级别。所有的 事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏 读、不可重复读以及幻读。 
 MySQL 默认采用的 REPEATABLE_READ 隔离级别。 

#### 10、可重复读解决了哪些问题？ 

 可重复读的核心就是一致性读(consistent read);保证多次读取同一个数据时，其值都和事 务开始时候的内容是一致，禁止读取到别的事务未提交的数据，会造成幻读。 
 而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就 需要进入锁等待。
 查询只承认在事务启动前就已经提交完成的数据。 
 可重复读解决的是重复读的问题，可重复读在快照读的情况下是不会有幻读，但当前读的 时候会有幻读。 

#### 11、对 SQL 慢查询会考虑哪些优化 ？

 分析语句，是否加载了不必要的字段/数据。 
 分析 SQL 执行计划（explain extended），思考可能的优化点，是否命中索引等。 
 查看 SQL 涉及的表结构和索引信息。 
 如果 SQL 很复杂，优化 SQL 结构。 
 按照可能的优化点执行表结构变更、增加索引、SQL 改写等操作。 
 查看优化后的执行时间和执行计划
 如果表数据量太大，考虑分表。
  利用缓存，减少查询次数。

#### 12、谈一谈缓存穿透、缓存击穿和缓存雪崩，以及解决办法？ 

##### 缓存穿透 

 问题：大量并发查询不存在的 KEY，在缓存和数据库中都不存在，同时给缓存和数据库 带来压力。 
 原因：一般而言，缓存穿透有 2 种可能性：业务数据被误删，导致缓存和数据库中都没 有数据。恶意进行 ddos 攻击。 
 分析：为什么会多次透传呢？不存在 一直为空，需要注意让缓存能够区分 KEY 不存在和 查询到一个空值。 
 解决办法：缓存空值的 KEY，这样第一次不存在也会被加载会记录，下次拿到有这个 KEY。Bloom 过滤或 RoaingBitmap 判断 KEY 是否存在，如果布隆过滤器中没有查到 这个数据，就不去数据库中查。在处理请求前增加恶意请求检查，如果检测到是恶意攻击， 则拒绝进行服务。完全以缓存为准，使用延迟异步加载的策略（异步线程负责维护缓存的 数据，定期或根据条件触发更新），这样就不会触发更新。 

##### 缓存击穿 

 问题：某个 KEY 失效的时候，正好有大量并发请求访问这个 KEY。 
 分析：跟穿透其实很像，属于比较偶然的。 
 解决办法：KEY 的更新操作添加全局互斥锁。完全以缓存为准，使用延迟异步加载的策 略（异步线程负责维护缓存的数据，定期或根据条件触发更新），这样就不会触发更新。 

##### 缓存雪崩 

 问题：当某一时刻发生大规模的缓存失效的情况，导致大量的请求无法获取数据，从而将 流量压力传导到数据库上，导致数据库压力过大甚至宕机。 
 原因：一般而言，缓存雪崩有 2 种可能性：大量的数据同一个时间失效：比如业务关系 强相关的数据要求同时失效 Redis 宕机 
 分析：一般来说，由于更新策略、或者数据热点、缓存服务宕机等原因，可能会导致缓存 数据同一个时间点大规模不可用，或者都更新。所以，需要我们的更新策略要在时间上合 适，数据要均匀分享，缓存服务器要多台高可用。 
 解决办法：更新策略在时间上做到比较平均。如果数据需要同一时间失效，可以给这批数 据加上一些随机值，使得这批数据不要在同一个时间过期，降低数据库的压力。使用的热 数据尽量分散到不同的机器上。多台机器做主从复制或者多副本，实现高可用。做好主从 的部署，当主节点挂掉后，能快速的使用从结点顶上。实现熔断限流机制，对系统进行负 载能力控制。对于非核心功能的业务，拒绝其请求，只允许核心功能业务访问数据库获取 数据。服务降价：提供默认返回值，或简单的提示信息

#### 23、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最 多能存放多少元素？ 

理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放 了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、和 sorted set 都可 以放 232 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。 

#### 24、Redis 数据结构 压缩列表和跳跃表的区别 

 压缩列表（ziplist）本质上就是一个字节数组，是 Redis 为了节约内存而设计的一种线性 数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。 30 
 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指 针，从而达到快速访问节点的目的。跳跃表支持平均 O（logN）、最坏 O（N）复杂度 的节点查找，还可以通过顺序性操作来批量处理节点

#### 28、谈谈自己对于 Spring AOP 的了解？ 

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块 所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统 的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 

#### 29、 Spring Bean 容器的生命周期是什么样的？ 

 Bean 容器找到配置文件中 Spring Bean 的定义。 
 Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。 
 如果涉及到一些属性值 利用 set()方法设置一些属性值。 
 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的 名字。 
 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法， 传入 ClassLoader 对象的实例。 
 如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory 对象的实例。 
 与上面的类似，如果实现了其他 *.Aware 接口，就调用相应的方法。  如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessBeforeInitialization() 方法 
 如果 Bean 实现了 InitializingBean 接口，执行 afterPropertiesSet()方法。  如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。  如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessAfterInitialization() 方法 
 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方 法。 
 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性， 执行指定的方法

#### 29、Lambda 表达式是啥？优缺点？ 

lambda 表达式，也被称为闭包，它是推动 Java 8 发布的最重要新特性。lambda 允许把函 数作为一个方法的参数（函数作为参数传递进方法中），使用 Lambda 表达式可以使代码变 的更加简洁紧凑。 
优点： 
 代码更加简洁  减少匿名内部类的创建，节省资源 
 使用时不用去记忆所使用的接口和抽象函数
 缺点：
  不易于后期维护，必须熟悉 lambda 表达式和抽象函数中参数的类型  可读性差 
 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热 才显示出效率优势） 
 不容易调试。 
 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂

#### 31、MySQL 事务的特性有什么，说一下分别是什么意思？ 

 原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。  一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态。 
 隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务。 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故 障，事务的处理结果也会得到保存

#### 15、Redis 常见的几种数据结构说一下？各自的使用场景？ 

string 介绍：string 数据结构是简单的 key-value 类型。 
使用场景： 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等 等。 
list 介绍：list 即是 链表 使用场景：发布与订阅或者说消息队列、慢查询。 hash 介绍：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。 使用场景：系统中对象数据的存储。 
set 介绍：set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元 素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的 选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不 能提供的。可以基于 set 轻易实现交集、并集、差集的操作 47 使用场景： 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景。 
sorted set 介绍：和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 使用场景：需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含 直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等 信息。 
bitmap 介绍：bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表 示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。。 使用场景：适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进 行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视 频）。

#### 24、Java 多线程有哪几种实现方式？ 

 通过继承 Thread 类创建线程类 
 实现 Runnable 接口创建线程类 
 通过 Callable 和 Future 接口创建线程

#### 5、MySQL 索引分类? 单列索引 

 普通索引：MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值 和空值，纯粹为了查询数据更快一点。 
 唯一索引：索引列中的值必须是唯一的，但是允许为空值，
 主键索引：是一种特殊的唯一索引，不允许有空值。 
组合索引： 多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使 用，使用组合索引时遵循最左前缀集合。 
全文索引： 只有在 MyISAM 引擎上才能使用，只能在 CHAR,VARCHAR,TEXT 类型字段上使用全文 索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就 能找到该字段所属的记录行，比如有"你是个靓仔，靓女 ..." 通过靓仔，可能就可以找到该条 记录 
空间索引： 空间索引是对空间数据类型的字段建立的索引，MySQL 中的空间数据类型有四种， GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用 SPATIAL 关 键字。要求，引擎为 MyISAM，创建空间索引的列，必须将其声明为 NOT NULL。 

#### 6、了解线程 & 进程的区别吗？ 

操作系统中可以拥有多个进程，一个进程里可以拥有多个线程，线程在进程内执行 进程和线程的区别 
 容易创建新线程。创建新进程需要重复父进程 
 线程可以控制同一进程的其他线程。进程无法控制兄弟进程，只能控制其子进程 
 进程拥有自己的内存空间。线程使用进程的内存空间，且要和该进程的其他线程共享这个 空间；而不是在进程中给每个线程单独划分一点空间。 
 （同一进程中的）线程在共享内存空间中运行，而进程在不同的内存空间中运行 
 线程可以使用 wait（），notify（），notifyAll（）等方法直接与其他线程（同一进程） 通信；而，进程需要使用“进程间通信”（IPC）来与操作系统中的其他进程通信

#### 1、据库三大范式是什么 

 第一范式：每个列都不可以再拆分。 
 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部 分。 
 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。 在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性 能。事实上我们经常会为了性能而妥协数据库的设计。